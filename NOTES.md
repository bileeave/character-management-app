# notes

my own documentation and takeaways.

https://laravel.com/docs

## contents

- [starters](#starters)
- [routes/](#routes)
   - [web.php](#webphp)
   - [api.php](#apiphp)
- [app/](#app)
   - [actions/vendor/](#actionsvendor)
   - [http/controllers](#httpcontrollers)
   - [http/controllers/settings](#httpcontrollerssettings)
   - [http/requests](#httprequests)
   - [models/](#models)
   - [models/scopes](#modelsscopes)
   - [providers/](#providers)
   - [helpers.php](#helpersphp)
- [resources/views/](#resourcesviews)
   - [auth/](#auth)
   - [auth/password/](#authpassword)
   - [...blade.php](#bladephp)
   - [components/](#components)
- [database/](#database)
   - [factories/](#factories)
   - [migrations/](#migrations)
   - [seeders/](#seeders)

## starters

[Laravel](https://laravel.com/docs/10.x) follows the [MVC pattern](https://selftaughtcoders.com/from-idea-to-launch/lesson-17/laravel-5-mvc-application-in-10-minutes/).

---

The [Laravel Learning Roadmap](https://laraveldaily.com/roadmap-learning-path) may help you with your learning path, as well as the [Laravel Bootcamp](https://bootcamp.laravel.com/).

---

Laravel [directory structure](https://laravel.com/docs/structure):

<pre>
├── app/                   : contains the business logic of the app.
│    ├── Http/
│    │    └── Controllers/ : the "C" in the MVC pattern. Manage user requests and data retrieval. https://laravel.com/docs/controllers
│    └── Models/           : the "M" of the MVC pattern. All interactions with the database table will be completed through here. https://laravel.com/docs/eloquent.
├── config/                : app configurations.
├── database/              : all files related to the database. https://laravel.com/docs/queries.
│    ├── factories/        : generate fake data to populate database for performance and unit testing.
│    ├── migrations/       : where you set table schemas or the “blueprint” of your database. Version control for databases. https://laravel.com/docs/migrations.
│    └── seeders/          : create fake data defined by you.
├── public/                : files that can be accessed publicly. You can place images, css, and javascript here.
├── resources/             : uncompiled css and javascript that can't be accessed by browser directly.
│    └── views/            : the "V" of the MVC pattern. Renders the user interface or UI.
├── routes/                : all route definitions.
│    ├── api.php           : api related route definitions.
│    └── web.php           : web route definitions. https://laravel.com/docs/routing.
├── storage/               : logs, compiled blade templates, file—based sessions, file caches and other files generated by the framework. https://laravel.com/docs/filesystem
├── tests/                 : files for automated tests.
├── vendor/                : all app's dependencies installed by the Composer. Avoid directly editing files here.
├── .env                   : configurations for the development environment. Key-value pairs are referenced from the config directory.
├── .env.example           : guide for other developers to have the application running. Does not include actual values in this file.
├── artisan                : file called when running `php artisan` to interact with the CLI.
├── composer.json          : details of the application and its dependencies.
├── package.json           : metadata and dependencies for frontend resources like CSS and JavaScript needed in Laravel.
└── vite.config.js         : configuration file for Vite.js, the next-generation frontend tool replacing webpack.mix.js used in Laravel 9 and below.
</pre>

<sup>Tree view [reference](https://bobbyhadz.com/blog/markdown-display-directory-and-file-structure).</sup>

---

To view the artisan commands, run `php artisan`.

---

For debugging SQL syntax for simple queries, try `php artisan tinker` and please do make use of [Laravel debugging](https://laravel.com/docs/queries#debugging) methods.

---

For debugging SQL syntax for multiple queries, use [Laravel Debug Bar](https://github.com/barryvdh/laravel-debugbar).

---

GitHub has a 72-character limit so we recommend keeping your commits’ subject to within this amount.

## routes/

### web.php

By convention, naming URI in resource route should be in plural form and in snake case for multiple words.

https://laravel.com/docs/routing

---

Routing with Controller:

https://laravel.com/docs/controllers

---

"-i" or "--invokable"

```php
Route::get('/', WelcomeController::class)->name("index");
Route::get("/home", DashboardController::class)->name("home");
```

https://laravel.com/docs/controllers#single-action-controllers

---

Group logic handling in controllers to make maintenance easier and avoid having a single giant route file.

```php
Route::controller(CharacterController::class)->prefix("character-ideas")->name("characters.")->group(function () {
   Route::get("/", "index")->name("index");
   Route::get("/create", "create")->name("create");
   Route::post("/", "store")->name("store");
   Route::get("/{character}", "show")->whereNumber("id")->name("show");
   Route::get("/{character}/edit", "edit")->name("edit");
   Route::put("/{character}", "update")->name("update");
   Route::delete("/{character}", "destroy")->name("destroy");
});
```

---

Regular expression constraints:

https://laravel.com/docs/routing#parameters-regular-expression-constraints

---

"-r" or "--resource". Resource route defines a route for multiple CRUD operations.

```php
Route::resource("characters", CharacterController::class);
Route::resource("groups", GroupController::class);
```

https://laravel.com/docs/controllers#resource-controllers

---

Naming resource route parameters:

https://laravel.com/docs/controllers#restful-naming-resource-route-parameters

https://laracasts.com/discuss/channels/laravel/naming-uri-resources-with-two-words

---

Resource and apiResource routes can have nested routes. Just specify the route path using dot notation.

`php artisan make:controller CharacterNote -r`

```php
Route::resource("/character.note", CharacterNoteController::class)
   ->shallow();
```

---

You may read about "shallow nesting" here:

https://laravel.com/docs/controllers#shallow-nesting

---

Define the import and export route before the resource route so that it matches the resource show route. Otherwise, Laravel's routing will assume that "import" in the URI is a route parameter, which doesn't exist, so it results in a 404 HTTP error.

---

Method chaining is calling methods together in a single statement. These methods may be applied in the example route below:

`except()` or `only()`, `name()` or `names()`, `parameter()` or `parameters()`.

```php
Route::resource("/activities", ActivityController::class)
   ->except(["index", "show"])
   ->names([
      "index" => "activities.all",
      "show" => "activities.view"
   ])
   ->parameter("activity", "action");
```

---

Apart from having named routes in your routes.php, the error "Route not defined" can also occur when you have duplicate URIs in your routes.

---

The root path for the "local" disk is "storage/app/". You can also find it in filesystems.php in the config directory.

---

The root path for the "public" disk is "storage/app/public". Set "FILESYSTEM_DISK" variable to "public" in the .env file to allow users to access public files. You may create a symbolic link of "storage/app/public" in the public directory:

`php artisan storage:link`

---

Remember to edit configuration values only in the .env file.

---

This route downloads a sample CSV file in "storage/public/" directory. The `download()` method passes the argument of the path to download. But make sure to add the sample CSV file to .gitignore file so it can be used in other environments.

```php
Route::get("/download", function () {
   return response()->download(Storage::path("characters-sample.csv"));
})->name("download");
```

https://laravel.com/docs/filesystem#file-urls

---

Eager loading for model with multiple relationships.

```php
Route::get("/eagerload-multiple", function () {
   $users = User::with(["groups", "characters"])->get();
   foreach ($users as $user) {
      echo $user->name . ":<br />";
      echo $user->groups->count() . " groups";
      echo $user->characters->count() . " characters";
   }
});
```

https://laravel.com/docs/eloquent-relationships#eager-loading

---

Eager loading for nested relationships. For example, the User model has Group and Character models. Group has Character model.

```php
Route::get("/eagerload-nested", function () {
   $users = User::with("groups", "groups.characters")->get();
   foreach ($users as $user) {
      echo $user->name . ":<br />";
      foreach ($user->groups as $group) {
         echo $group->name . " group has" .
            $group->characters->count() .
            " characters<br>";
      }
      echo "<br />";
   }
});
```

---

Eager loading with query constraints. Pass an array of relationships in the `with()` method where the array key is a relationship name, and the array value is a closure (an anonymous function) that adds additional constraints to the eager loading query.

```php
Route::get("/eagerload-constraints", function () {
    $users = User::with([
      "groups" => function ($query) {
        $query->where("name", "like", "%.Jane");
      }
    ])->get();
    foreach ($users as $user) {
        echo  $user->name . "<br />";
        foreach ($user->groups as $group) {
            echo $group->name . "<br />";
        }
        echo "<br />";
    }
});
```

---

Lazy eager loading loads a relationship after the parent model has already been retrieved. It is performed using the `load()` method, and additional query constraints can also be set in it.

```php
Route::get("/eagerload-lazy", function () {
   $users = User::get();
   $users->load([
      "groups" => function ($query) {
         $query->orderBy("name");
      }
   ]);
   foreach ($users as $user) {
      echo  $user->name . "<br />";
      foreach ($user->groups as $group) {
         echo $group->name . "<br />";
      }
      echo "<br />";
   }
});
```

https://laravel.com/docs/eloquent-relationships#lazy-eager-loading

---

Eager loading by default is when you always want to load certain relationships when retrieving a model. To accomplish this, define a `$with` property on the model and specify the relationship names in an array. The `with()` method does not apply on this since it's already defined in the model, but you may use the `without()` and `withOnly()` methods.

```php
Route::get("/eagerload-default", function () {
   /**
    * Disabled the nested code block below due to the default eager
    * loading set up in the parent model.
    * You can disable a query by using the `without()` method.
    */
   $users = User::without("characters", "groups")->get();
   foreach ($users as $user) {
      echo  $user->name . "<br />";  
      // foreach ($user->groups as $group) {
      //     echo $group->name . "<br />";
      // }
      // echo "<br />";
   }
});
```

https://laravel.com/docs/eloquent-relationships#eager-loading-by-default

---

Before deciding to eager load your models by default, ensure that the relationships you eagerly load are always needed in your query; otherwise, you'll get unnecessary queries.

---

If you want to count the number of related models for a given relationship without actually loading the models, you may use the `withCount()` method or the `loadCount()` method to load a relationship count after the parent model has already been retrieved.

```php
Route::get("/count-models", function () {
   $users = User::withCount(["characters", "groups"])->get();
   foreach ($users as $user) {
      echo $user->name . " <br />";
      echo $user->groups_count . " groups<br />";
      echo $user->characters_count . " characters<br />";
      echo "<br />";
   }
});
```

https://laravel.com/docs/eloquent-relationships#aggregating-related-models

---

You can find more middleware aliases such as "auth" and "verified" in Kernel.php.

```php
Route::middleware(["auth", "verified"])->group(function () {
   // routes here
}); 
```

https://laravel.com/docs/middleware#registering-middleware

---

Fallback route should always be the last route registered.

```php
Route::fallback(function () {
   return abort(404);
});
```

### api.php

The API excludes the `create()` and `edit()` methods from the resource controller because, in an API, there is no need for a server to provide a form (rendering HTML forms for user interaction), but to send back JSON data (sending and receiving structured data).

`php artisan make:controller API\Character --api`

---

You can also group API resource the same with resource.

```php
Route::apiResources([
   "/uri", ClassName::class,
   // ...
]);
```

## app/

### actions/vendor

If using Laravel Fortify as an authentication vendor, change the `validateWithBag()` to `validate()` method to show the input validation errors in the view.

### http/controllers

Show the groups that only belong to the current user signed in.

```php
protected function currentUserGroups () {
   return Group::currentUser(auth()->user())
      ->orderBy("name")
      ->pluck("name", "id");
}
```

---

Count the total number of groups. Not coded for the current user signed in.

```php
$data = [];
$groups = Group::orderBy("name")->get();
foreach ($groups as $group) {
   $data[$group->id] = $group->name . " (" . $group->characters()->count() . ")";
}
return $data;
```

---

Public, protected, and private are access modifiers. Public, any class can call the method. Protected, only the current class and subclasses can have access to the method. Private, only the current class will have access to the method.

---

You can enable the query log by wrapping up the code statement with it to debug its database query.

```php
DB::enableQueryLog();
   // code statement
dump(DB::getQueryLog());
```

---

You may add multiple table columns in `sortByColumn()` method. It's second parameter is the default sorting column. The method `sortByColumn()` is defined in [scopes](#models--scopes).

```php
   public function index () {
      $characters = Character::showTrash()
         ->sortByColumn(["name"], "-id")
         // ...
         ;
   }
```

---

Separate the filter functionality: selecting a group and typing in the search. The output will display search results based on the selected group from the dropdown. Enabling query logging for this code statement verifies that it groups the queries separately, meeting the expectation.

```php
   public function index () {
      $characters = Character::showTrash()
         ->sortByColumn(["name"], "-id")
         ->filterByGroup("group_id")
         ->filterBySearch(["name", "details"])
         // ...
         ;
   }
```

---

If you're defining a method with spread operator, then remove the array brackets to its argument when calling the method.

---

In Laravel Fortify, the `auth()` method is called to display the characters that belong to the current authenticated user. With this, you can retrieve the current user instance (the User model) and then access its model relationships, if it has:

```php
$characters = auth()->user()->characters()
   ->allowedTrash()
   // ...
   ;
```

---

The current authenticated user can be also defined in a method and reused to methods. It can be defined in a trait and call it.

```php
   public function index () {
      $characters = Character::showTrash()
         ->sortByColumn(["name"], "-id")
         ->filterByGroup("group_id")
         ->filterBySearch(["name", "details"])
         ->currentUser(auth()->user())
         // ...
         ;
   }
```

---

The `with()` optimizes the query with eager loading by specifying its relationship name as defined in the model. It fixes the "N+1" query problem where many queries are being performed. This problem occurs when the code needs to load the children of a parent-child relationship (the “many” in the “one-to-many”). More elaboration in [web.php](#webphp).

https://www.sitepoint.com/silver-bullet-n1-problem/#whatisthen1queryproblem
https://www.appdynamics.com/blog/product/common-application-problems-and-how-to-fix-them-the-select-n-1-problem/

---

Make sure you don’t end up running unnecessary queries while looping through an object.

---

The request dependency injection is by default used in `store()` and `update()` methods. We can also make our own custom request.

https://laravel.com/docs/requests

---

Dependency injection means to inject the class dependencies into the class via the constructor or methods.

---

If called, the `store()` method will be executed method only if the validation in form request passes.

```php
public function store (CharacterRequest $request) {
   Character::create($request->only("name", "details", "location", "group_id"));
   return redirect()->route("characters.index")
      ->with("message", "Character added");
```

---

Define the mass assignment in the model to `$guarded = [];` if you want to specify the columns in this controller.

```php
Character::create($request->only("name", "details", "location", "group_id"));
```

---

Define the mass assignment in the model to `$fillable = ["table_column", "table_column"];` if you want to request all columns in this controller.

```php
Character::create($request->all());
```

---

The `Character::create($request->all());` has been modified to include the user's id when saving new characters.

```php
public function store (CharacterRequest $request) {
   $request->user()->characters()->create($request->all());
   return redirect()->route("characters.index")
      ->with("message", "Character added");
}
```

https://laravel.com/docs/responses

---

Using the implicit route model binding in this controller, so we no longer need the query to find the table's id. Route Model Binding automatically injects the model instances directly into your routes or into your controllers. Run route list to check for the route's parameter.

```php
public function show (Character $character) {
   return view("characters.show")->with("character", $character);
}
```

https://laravel.com/docs/routing#route-model-binding

---

Opt for `redirect()->route()` over `back()` in this scenario. This choice is advisable because returning to a deleted page using `back()` may trigger a 404 HTTP error since the page no longer exists. The variable `$redirect` checks for the presence of "redirect" in the query string, a parameter defined in the [index view](#bladephp).

```php
public function destroy (Character $character) {
   $character->delete();
   $redirect = request()->query("redirect");
   return ($redirect ? redirect()->route($redirect) : back())
      ->with("message", "Character moved to trash")
      ->with("undo", undoOnce("characters.restore", $character));
}
```

---

Based from the `destroy()` method above, the `undoOnce()` is a helper function stored in variable "undo" to be passed to the view to undo the last action.

```php
function undoOnce ($routeName, $instance) {
   return request()->missing("undo") ? route($routeName, [$instance->id, "undo" => true]) : null;
}
```

---

We don't need to get the "redirect" query string in `restore()` method since it's only called from the index view. All we need to do is return the `back()` function to redirect back to the previous page.

```php
public function destroy(Character $character)
{
   $redirect = request()->query("redirect");
   return ($redirect ? redirect()->route($redirect) : back())
      ->with("message", "Character moved to trash")
      ->with("undo", undoToast("characters.restore", $character));
}

public function restore (Character $character) {
   $character->restore();
   return back()
      ->with("message", "Character restored")
      ->with("undo", showUndoOnce("characters.destroy", $character));
}
```

---

Eager loading with `loadCount()`.

```php
public function __invoke(Request $request)
{
   $user = $request->user()->loadCount(["groups", "characters"]);
   return view("shared.dashboard", compact("user"));
}
```

https://laravel.com/docs/eloquent-relationships#deferred-count-loading

---

Always apply eager loading when accessing the relationship model.

---

The first method in ExportController.php. Pass the `$columns` variable to the view to make it accessible for exporting.

```php
public function create () {
   $columns = ["name", "details", "location", "group"];
   return view("characters.export", compact("columns"));
}
```

---

The second and last method in ExportController.php. The second argument of `streamDownload()` method specifies the CSV file name. The third argument specifies the response header in an array so that we download the right file type and not ".html".

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      // ...
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

The `fopen()` method opens the stream and close it with `fclose()`.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      // ...
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

The `fputcsv($resource, $columns);` writes a line containing the column names separated by commas.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      fputcsv($resource, $columns);
      $characters->each(function ($row) use ($columns, $resource) {
         // ...
         fputcsv($resource, $rowData);
      });
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

You can replace the `each()` method with `foreach()` loop.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      fputcsv($resource, $columns);
      $characters->each(function ($row) use ($columns, $resource) {
         // ...
         fputcsv($resource, $rowData);
      });
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

Iterate over the array of columns retrieved from the view and passed from the `create()` method in ExportController.php.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      fputcsv($resource, $columns);
      $characters->each(function ($row) use ($columns, $resource) {
            $rowData = [];
            foreach ($columns as $column) {
               // ...
            }
            fputcsv($resource, $rowData);
      });
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

Since the `$columns` array contains "group", which doesn't exist in the database table (it's "group_id" instead), we need to perform a simple check if the "group" is selected for export. If it is not selected, we push the values directly to an array.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      fputcsv($resource, $columns);
      $characters->each(function ($row) use ($columns, $resource) {
            $rowData = [];
            foreach ($columns as $column) {
               if ($column === "group") {
                  // ...
               } else {
                  $rowData[] = $row->{$column};
               }
            }
            fputcsv($resource, $rowData);
      });
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

If "group" is selected, we need to check if it has a value (is set). If it does, we push it to the array; otherwise, we push it with a value of NULL. This resolves the issue of receiving an invalid response (Status Code 500 Internal Server Error) when selecting an empty "group" for export.

```php
public function store (ExportCharacterRequest $request) {
   $columns = $request->columns;
   $characters = Character::currentUser($request->user())
      ->with("group")
      ->latest()
      ->get();
   return response()->streamDownload(function () use ($characters, $columns) {
      $resource = fopen("php://output", "w");
      fputcsv($resource, $columns);
      $characters->each(function ($row) use ($columns, $resource) {
            $rowData = [];
            foreach ($columns as $column) {
               if ($column === "group") {
                  $rowData[] = !isset($row->group->name) ?  NULL  : $row->group->name;
               } else {
                  $rowData[] = $row->{$column};
               }
            }
            fputcsv($resource, $rowData);
      });
      fclose($resource);
   }, "characters" . time() . ".csv", [
      "Content-Type" => "text/csv"
   ]);
}
```

---

To make sure the scopes trait works, ensure that it is applied to the current controller's model.

---

The `filterBySearch()` method searches for groups by their given array of column names.

```php
public function index()
{
   $groups = Group::showTrash()
      ->sortByColumn(["name"], "-id")
      ->filterBySearch(["name"])
      ->currentUser(auth()->user())
      // ...
   return view("groups.index", compact("groups"));
}
```

---

Relationship counting with `withCount()` method in GroupController.php.

```php
public function index()
{
   $groups = Group::showTrash()
      ->sortByColumn(["name"], "-id")
      ->filterBySearch(["name"])
      ->currentUser(auth()->user())
      ->withCount("characters")
      ->paginate(5);
   return view("groups.index", compact("groups"));
}
```

https://laravel.com/docs/eloquent-relationships#relationship-counting-and-custom-select-statements
https://laravel.com/api/master/Illuminate/Database/Eloquent/Concerns/QueriesRelationships.html#method_withCount

---

The `Group::currentUser(auth()->user())` in ImportCharacterController.php retrieves all groups from the authenticated user.

```php
public function create () {
   $groups = Group::currentUser(auth()->user())
      ->orderBy("name")
      ->pluck("name", "id");
   return view("characters.import", compact("groups"));
}
```

---

The default validation injected is the Request class, but we can make our own request and define the constraints there.

```php
public function store (ImportCharacterRequest $request) {
   $columns = $request->getCsvData();
   foreach ($columns as $column) {
      $request->user()->characters()->create([
         "name" => $column[0],
         "details" => $column[1],
         "location" => $column[2],
         "group_id" => $request->group_id
      ]);
   }
   return redirect()->route("characters.index")
      ->with("message", "Characters imported successfully");
}
```

### http/controllers/settings

Creating a directory to group controller files is optional and depends on the developer's preference.

---

Create the view manually or the "GET" method for the Fortify route named "user-password.update" and "user/profile-information" since the vendor only supports the update or 'PUT' method.

```php
public function __invoke(Request $request)
{
   return view("settings.password");
}
```

```php
public function __invoke(Request $request)
{
   return view("settings.profile-information", [
      "user" => $request->user()
   ]);
}
```

### http/requests

Form Request is a custom request class that encapsulates the validation logic such as validation rules, error messages, and even authorization logic rather than writing it directly in the controller.

https://laravel.com/docs/validation#form-request-validation

---

The "character" is the route name when you run the route list. If the route model binding is set up, this method will return the "id" which is the default column.

`dd($this->route("character"));`

---

The `method()` method returns the HTTP method when the request is sent.

`dd($this->method());`

https://laravel.com/docs/validation#authorizing-form-requests

---

Validation doesn't interact with the database, it interacts with the Request.

https://laravel.com/docs/validation

---

If the field is an email, add an "email" rule to the validation. Verify whether "group_id" exists in the "groups" table with its primary key "id"—and ensure the table exists. The "min:2" indicates a minimum of two items.

```php
public function rules(): array
{
   return [
      "name" => "required|string|max:50",
      "details" => "nullable|string|max:1000",
      "location" => "nullable",
      "image" => "required|image",
      "columns" => "required|array|min:2"
      "group_id" => "nullable|exists:groups,id"
   ];
}
```

---

Set `authorize()` method to true if the current user is authorized to make request.

---

Override the methods `attributes()` and `messages()`.

```php
public function attributes()
{
   return [
      "group_id" => "group"
   ];
}

public function messages()
{
   return [
      "*.required" => "The :attribute must not be empty."
   ];
}
```

https://laravel.com/docs/validation#working-with-error-messages

### models/

Create model with migration command.

`php artisan make:model Design -m`

---

Create a model with a migration, seeder, and/or factory command if you want to seed the table with fake or test data.

`php artisan make:model Note -msf`

---

The naming convention for the model file is to use the singular form of your table name, with each separate word capitalized in camel case.

```
   Table               Model
activities          Activity
people              Person
purchase_orders     PurchaseOrder
men                 Man
```

---

Define `$guarded` or `$fillable` in the model to enable mass assignment to the database. Specifying the table columns in the `$guarded` array disallows mass assignment to them, while `$fillable` allows mass assignment. Failing to initialize `$guarded` or `$fillable` in the model will result in a Mass Assignment Exception error.

`protected $guarded = [];`

`protected $fillable = ["name", "details", "location", "group_id"];`

---

If your table name and model name don't follow the same naming convention, you can specify the table name in the model using the `$table` property.

`protected $table = "app_companies";`

---

If the primary key of your table is not named "id", you can specify it in the model using the `$primaryKey` property.

`protected $primaryKey = "_id";`

---

Soft deletion is a technique used to retain models in the database even after they are deleted. Two steps are required to implement soft deletion:

1. Add a new column named "deleted_at" to record the date and time when the model was deleted.
2. Implement soft deletion in the model.

https://laravel.com/docs/eloquent#deleting-models

---

Include the groups that are trashed or soft deleted. This resolves the issue of accessing null objects in the view when a group associated with the character is deleted. Another solution is chaining the `withTrashed()` method in the relationship `group()` method defined in the parent model to establish a link with a deleted relationship.

```php
public function group () {
   return $this->belongsTo(Group::class)->withTrashed();
}
```

---

To link the "user_id" column in the "groups" and "characters" tables to the "id" column in the "users" table, define their relationships in its models.

```php
public function groups () {
   return $this->hasMany(Group::class);
}

public function characters () {
   return $this->hasMany(Character::class);
}
```

---

When defining the relationship associated to the model base it from the class name of its related model.

https://laravel.com/docs/eloquent-relationships#introduction

---

Defining the parent model with `hasMany()`, then define the child model with `belongsTo()`. This establishes the one-to-many relationship and its inverse relationship.

```php
public function tasks () {
   return $this->hasMany(Task::class);
}

public function user () {
   return $this->belongsTo(User::class);
}
```

---

The `hasMany()` method takes two arguments: the child class and its optional foreign key. If you adhere to the naming convention for the foreign key, specifying it is not required; otherwise, you must provide it. The naming convention involves using the referenced table's name followed by suffixing it with an underscore, followed by the primary key column name, for example, "group_id".

---

Set the method to static if you don't want to instantiate its class when calling the method from outside of its class.

---

To list all files from a specific directory, use `allFiles()` method.

```php
public static function makeDirectory () {
   return Storage::makeDirectory("designs/" . date("Y-m-d"));
}
```

---

Return the path of the image file and retrieve its size. You may try it in tinker!

```php
$filesInDirectory = Storage::allFiles("images/");
$filePath = Storage::path($filesInDirectory[3]);
getimagesize($filePath);
```

https://laravel.com/docs/filesystem#file-paths

---

The `getimagesize()` method returns an array of image sizes.

```php
public static function getDimensions ($image) {
   [$width, $height] = getimagesize(Storage::path($image));
   return $width . "x" . $height;
}
```

---

Display if there is a profile picture in the database and if it exists on the disk.

```php
public function profilePictureUrl () {
   return $this->profile_picture && Storage::exists($this->profile_picture) ? Storage::url($this->profile_picture) : "https://via.placeholder.com/150x150";
}
```

---

From default eager loading in [web.php](#webphp).

```php
protected $with = ["characters", "groups"];
```

### models/scopes

Query Scopes in Laravel allow you to create a reusable set of constraints for your model, such as sorting. You can call these scopes in the controller to replace your model constraints. Soft deletion is an example of global scopes from Laravel, but you may also write your own global scopes for soft deletion. Local scopes can be defined within the model and must be prefixed with "scope".

https://laravel.com/docs/eloquent#query-scopes

---

To make the scopes reusable across all models, create a trait file, import its namespace "App\Models\Scopes", and "use" the trait name in the model where you want to use its methods.


```php
namespace App\Models\Scopes;
trait CustomSoftDeletes {
   protected static function bootCustomSoftDeletes(): void
   {
      static::addGlobalScope(new CustomSoftDeletes);
   }
}
```

---

Traits are nothing but a reusable collection of methods and functions that can be incorporated into any other classes. Don't forget to "use" the trait in the model to call the methods defined the trait.

```php
trait Filter {
   public function parseColumnSort ($column = null) {
      return strpos($column ?? request()->query("sort_by"), "-") === 0 ? "desc" : "asc";
   }

   public function parseColumnTrim ($column = null) {
      return ltrim($column ?? request()->query("sort_by"), "-");
   }
   
   public function scopeSortByColumn (Builder $query, array $columns, $defaultColumn = null) {
      $column = $this->parseColumnTrim();
      if (in_array($column, $columns)) {
         return $query->orderBy($column, $this->parseColumnSort());
      }
      if (!$column && $defaultColumn)  {
         return $query->orderBy($this->parseColumnTrim($defaultColumn), $this->parseColumnSort($defaultColumn));
      }
      return $query;
   }

   public function scopeFilterByGroup (Builder $query, ...$keys) {
      foreach ($keys as $key) {
         if ($value = request()->query($key)) {
            $query->where($key, $value);
         }
      }
      return $query;
   }
   
   public function scopeShowTrash (Builder $query) {
      if (request()->query("trash")) {
         $query->onlyTrashed()->latest("deleted_at");
      }
      return $query;
   }
}
```

---

Make a global scope reusable across all models. Following the Laravel's documentation on [global scopes](https://laravel.com/docs/11.x/eloquent#global-scopes), define the `extend()` method so you can add your own methods in the scope. Define your own methods with `macro()` method to register them to the builder instance. You can then move the `booted()` static method defined in the model to the created trait file (refer above). And rename the static method, prefixed with "boot" then the trait name.

```php
public function apply(Builder $builder, Model $model): void
{
   $builder->whereNull('deleted_at');
}

public function extend(Builder $builder) {
   $this->addWithTrashed($builder);
   $this->addOnlyTrashed($builder);
}

public function addWithTrashed(Builder $builder) {
   $builder->macro("withTrashed", function (Builder $builder) {
      return $builder->withoutGlobalScope($this);
   });
}

public function addOnlyTrashed(Builder $builder) {
   $builder->macro("onlyTrashed", function (Builder $builder) {
      return $builder->withoutGlobalScope($this)->whereNotNull("deleted_at");
   });
}
```

---

If you want your local scopes to be reusable across all models, move them to a created trait file in the "Models/Scopes/" directory. Import its namespace. Set the trait name the same as the file name. Move your local scope methods in the trait. And "use" the trait name in the model where you want to call the scope methods. The parameter `$query` represents the Eloquent builder instance to constrain the query to only include the published images.

```php
public function scopePublished ($query) {
   return $query->where("is_published", true);
}
```

---

You can use the spread operator instead of `array`, but make sure when calling the method you don't use array to its argument.

```php
public function scopeFilterBySearch (Builder $query, array $keys) {
   if ($search = request()->query("search")) {
      foreach ($keys as $index => $key) {
         $method = $index === 0 ? "where" : "orWhere";
         $query->{$method}($key, "LIKE", "%{$search}%");
      }
   }
   return $query;
}
```

---

The `whereBelongsTo($user)` is a simplified version of `where("user_id", $user->id)`.

```php
public function scopeCurrentUser (Builder $query, User $user) {
   return $query->whereBelongsTo($user);
}
```

---

Notice the Builder instance injected in the methods.

### providers/

You can define here what bootstrap version to use.

```php
/**
* Bootstrap any application services.
*/
public function boot(): void
{
   Paginator::useBootstrapFour();
}
```

---

You can change the path of your application's "home" route in RouteServiceProvider.php.

---

Define the unregistered view routes of a vendor in the vendor's provider file.

```php
public function register(): void
{
   Fortify::registerView(function () {
      return view("auth.register");
   });

   Fortify::loginView(function () {
      return view("auth.login");
   });

   Fortify::requestForgotPasswordView(function () {
      return view("auth.password.request");
   });

   Fortify::resetResetPasswordView(function () {
      return view("auth.password.edit");
   });

   Fortify::verifyEmailView(function () {
      return view("auth.verify-email");
   });
}
```

### helpers.php

Functions in this helper file are custom functions that can be called from anywhere in this Laravel application. But you have to add the path of this to composer.json in order to register it in your project. Run `composer dump-autoload` command after finalizing changes to composer.json.

```json
"autoload": {
   "psr-4": {
      // ...
   },
   "files": [
      "app/helpers.php"
   ]
},
```

https://laravel.com/docs/helpers

---

There's no need to define the helper functions with access modifiers as they are designed to be globally accessible within the application.

```php
function sortable ($label, $column = null) {
   $column = $column ?? Str::snake($label);
   $sortBy = request()->query("sort_by");
   $direction = "";
   if (ltrim($sortBy, "-") === $column) {
      $direction = strpos($sortBy, "-")  === 0 ? "desc" : "asc  ";
   }
   $sortBy = !$sortBy || strpos($sortBy, "-") === 0 ? $column : "-{$column}";
   $url = request()->fullUrlWithQuery(["sort_by" => $sortBy]);
   return "<a href='{$url}' class='sortable {$direction}'>{$label}</a>";
}

function showUndoOnce ($routeName, $instance) {
   return request()->missing("undo") ? route($routeName, [$instance->id, "undo" => true]) : null;
}
```

## resources/views

### auth

Cookies such as login and "remember me" token can be cleared through the browser's developer tools, under Application.

---

When using a vendor, make a habit to run vendor's route list to check for its controller, route name, request method, and etc.

```
<h1 class="p-4 border-bottom">Register</h1>
<form action="{{ route("register") }}" method="POST">
   @csrf
   <!-- ... -->
</form>
```

### auth/password

If you used a vendor for authentication like Laravel Fortify, examine the vendor route list and you'll find that the route named "password.request" uses the "GET" method to request the forgot password view, then submits the input for password reset through route method of "POST".

```
<a href="{{ route("password.request") }}">Forgot your password?</a>
```

---

Set up the mail configuration variables in the .env file for testing the send email. You can set the value of "MAIL_MAILER" to "log" to store the logs in a log file, or "smtp" and use one of Laravel's supported mail transport drivers. In this case, we're using "smtp" with Mailtrap as its mail host. Just sign in to mailtrap.io, add an inbox, navigate to the SMTP settings, find the integrations, and select "Laravel 9+". Then, copy the SMTP configuration values to .env file.

```
<div class="px-4 py-4">
   @if ($message = session("status"))
      <div class="alert alert-success">{{ $message }}</div>
   @endif
   <form action="{{ route("password.email") }}" method="POST">
      @csrf
      <div class="mb-3">
         <label for="email" class="form-label">Email</label>
         <input type="email" class="form-control @error("email") is-invalid @enderror" name="email" value="{{ old("email") }}" />
         @error('email')
            <div class="invalid-feedback">{{ $message }}</div>
         @enderror
      </div>
      <div class="mb-3">
         <button type="submit" class="btn btn-block btn-primary">Send password reset link</button>
      </div>
   </form>
</div>
```

---

After password request or "Forgot your password?", an email will be sent containing the link for reset password's view along with its token. There is no "GET" method for resetting password in Laravel Fortify so make sure you register the custom view in the vendor's service provider file. After submission of the new password, the password will be updated using the "POST" method, "password.update" route name.

```
<div class="mb-3">
   <label for="password" class="form-label">Password Confirmation</label>
   <input type="password" class="form-control @error("password_confirmation") is-invalid @enderror" name="password_confirmation" />
   <input type="hidden" name="token" value="{{ request()->route("token") }}">
   @error('password_confirmation')
      <div class="invalid-feedback">{{ $message }}</div>
   @enderror
</div>
```

### ...blade.php

Anytime you define a "POST", "PUT", "PATCH", or "DELETE" HTML form in your application, you should include a hidden CSRF _token field in the form so that the CSRF protection middleware can validate the request.

https://laravel.com/docs/csrf

---

For naming convention, name input names the same as database column name.

---

Class "fa fa-icon-name" corresponds to Font Awesome icons.

---

If uploading a file, add the "enctype" attribute with the value "multipart/form-data". The file is attached using an input type of "file".

```
<form action="{{ route("characters.import.store") }}" method="POST" enctype="multipart/form-data">
   @csrf
   @method("put")
   <!-- Accepts all types of image. -->
   <input type="file" name="profile_picture" accept="image/*">
</form>
```

---

In some cases, if selecting the input file doesn't work, define this code within the Blade component tag.

```
@push('scripts')
   <script src="https://cdn.jsdelivr.net/npm/bs-custom-file-input/dist/bs-custom-file-input.min.js"></script>
   <script>
   $(document).ready(function () {
      bsCustomFileInput.init()
   })
   </script>
@endpush
```

---

Update the "APP_URL" in the .env file from "http://localhost" to "http://127.0.0.1:8000" because the Storage instance `url()` method retrieves from the URL. This resolves the issue of images not displaying in the view.

```
<img src="{{  $user->profilePictureUrl() }}" alt="...">
```

---

Placing these in the main layout will load it in every page. Instead, we use the directives `@stack` and `@push` to specify the styles and scripts a specific page will utilize.

```
@push('styles')
   <link href="{{ asset("css/bootstrap.min.css") }}" rel="stylesheet">
@endpush

@push('scripts')
   <script src="{{ asset("js/bootstrap.min.js") }}"></script>
@endpush
```

https://laravel.com/docs/blade#stacks

---

Variable "dropdown" is defined in the parent view and called in its component view in "components/shared/filter.blade.php".

```
@include("components.shared.filter", ["dropdown" => "components.characters.dropdown"])
```

---

In this example, the `sortable()` helper function method (defined in [helpers.php](#helpersphp)) takes the table's header as an argument. It's expected to match the table's name, but if not, it can be specified in the second parameter. For instance, if the table header is "First Name" but the corresponding column in the database table is "firstName", utilize the `{!! !!}` syntax to escape the HTML code set in the helper function.

```
<th scope="col">{!! sortable("Name") !!}</th>
```

---

Unlike the standard `{{ }}` blade syntax, which automatically escapes content to prevent cross-site scripting (XSS) attacks, the `{!! !!}` syntax does not escape the data. This can be useful when you need to display raw HTML or other content without modifications. However, avoid using user-supplied data in this manner as it can lead to XSS attacks.

---

Switch directives from `@each` to `@forelse` in order to access the variables from the parent view.

```
@each("components.list", $characters, "character", "empty")
```

```
@forelse ($characters as $item => $character)
   @include("components.characters.list", ["character" => $character, "item" => $item])
@empty
   @include('components.shared.list-empty', ["numCol" => 6, "message" => "No character found"])
@endforelse
```

https://laravel-news.com/laravel-blade-each

---

Pagination

```
{{ $characters->withQueryString()->links() }}
```

---

Run `php artisan vendor:publish` command to publish any editable assets from vendor packages, allowing you to access vendor files and customize them according to your preferences.

---

Define the query string "redirect" in the index view.

```
@include('components.shared.destroy', ["action" => route("characters.destroy", ["character" => $character->id, "redirect" => "characters.index"]), "buttonStyle" => "toWord"])
```

---

The `$images` variable is passed from the controller, allowing us to indirectly access table columns via eloquent model that is defined in the controller.

```
@foreach ($images as $image)
   <a href=""><img src="{{ $image->fileUrl() }}" alt="{{ $image->title }}"></a>
@endforeach
```

### components

The `onchange` event occurs when the value of an HTML element is changed.

```
<select class="custom-select filter-select" name="group_id" onchange="this.form.submit()">
   <option value="" selected>All Groups</option>
   @foreach ($groups as $id => $group)
      <!-- Or `@if ($id == request("group_id") selected @endif>`. -->
      <option value="{{ $id }}" @if ($id == request()->query("group_id")) selected @endif>{{ $group }}</option>
   @endforeach
</select>
```

---

The `@error("input_name")` directive checks for validation errors.

```
<input type="text" name="name" id="name" class="form-control @error("name") is-invalid @enderror" value="{{ old("name", $character->name) }}">
@error("name")
   <div class="invalid-feedback">{{ $message }}</div>
@enderror
```

---

The `old()` function accepts two arguments: input name and the default value of the input.

---

To prevent errors when accessing properties or methods on potentially null objects, you can utilize the Laravel `optional()` helper function to wrap the group instance `$character->group`. Alternatively, you can address this issue by chaining the `withTrashed()` method in the relationship method within the model associated with this view.

```
<td>{{ ($character->group) ? $character->group->name : "Not grouped" }}</td>
<td width="150">
   @if ($trashButtons)
      @include('components.shared.restore', ["action"=> route("characters.restore", $character->id)])
      @include('components.shared.force-delete', ["action" => route("characters.forceDelete", $character->id)])
   @else    
         <a href="{{ route("characters.show", $character->id) }}" class="btn btn-sm btn-circle btn-outline-info" title="Show"><i class="fa fa-eye"></i></a>
         <a href="{{ route("characters.edit", $character->id) }}" class="btn btn-sm btn-circle btn-outline-secondary" title="Edit"><i class="fa fa-edit"></i></a>
      @include('components.shared.destroy', ["action"  => route("characters.destroy", $character->id)])
   @endif
</td>
```

---

The "characters_count" is based on the aggregating related model, as explained in the [web.php](#webphp). Call this in its controller for this to work.

```
<td><a href="{{ route("characters.index", ["group_id" => $group->id]) }}">{{ ($group->characters) ? $group->characters_count : "No characters" }}</a></td>
```

---

We use a button instead of an anchor tag because we need to send the request.

```
<form action="{{ $action }}" method="POST" style="display: inline">
   @csrf
   @method("delete")
   @if (isset($buttonStyle) && $buttonStyle === "toWord") 
      <button type="submit" class="btn btn-outline-danger" title="Delete">Delete</button>
   @else
      <button type="submit" class="btn btn-sm btn-circle btn-outline-danger" title="Delete"><i class="fa fa-trash"></i></button>
   @endif
</form>
```

---

If you use the `confirm()` JavaScript method, make sure to return it so that the "cancel" option works.

```
<form method="" onsubmit="return confirm('Are you sure?')">
```

---

Ignore the attribute `action` to send the form to the current page.

---

This hidden input syncs the contents of a dropdown menu to the trash feature.

```
<input type="hidden" name="trash" value="{{ request()->query("trash") }}">
```

---

If there's a variable "dropdown" defined from the parent view of this.

```
@isset($dropdown)
   @includeIf($dropdown)
@endisset
```

---

Make the reset button for selection and search only accessible in characters view and not in groups view.

```js
<script>
   function resetUrl(url) {
      return url.split(/[?#]/)[0];
   }
   document.querySelector("#resetBtn").addEventListener("click", () => {
      let input = document.querySelector('#filter-search');
      let selects = document.querySelectorAll('.filter-select');
      if (input) {
         input.value =  "";
      }
      selects.forEach(select => {
         select.selectedIndex = 0;
      });
      window.location.href = resetUrl(window.location.href);
   });
   const toggleClearButton = () => {
      let query = location.search;
      let pattern = /[?&]search=/;
      let button = document.querySelector("#reset");
      if (pattern.test(query)) {
         button.style.display = "block";
      } else {
         button.style.display = "none";
      }
   }
   toggleClearButton();
</script>
```

---

The `split()` returns an array.

```js
function resetUrl(url) {
   return url.split(/[?#]/)[0];
}
```

---

Reset the current page without the query strings.

```js
window.location.href = resetUrl(window.location.href);
```

---


This pattern matches "?search=" or "?group_id&search=".

```js
let pattern = /[?&]search=/;
```

---

This code sets the reset button's visibility if it matches the pattern.

```js
const toggleClearButton = () => {
   let query = location.search;
   let pattern = /[?&]search=/;
   let button = document.querySelector("#reset");
   if (pattern.test(query)) {
      button.style.display = "block";
   } else {
      button.style.display = "none";
   }
}
toggleClearButton();
```

---

Before the refactor of button reset.

```
@if (request()->filled("search") || request()->filled("group_id"))
   <button class="btn btn-outline-secondary" type="button" title="Refresh" onclick="document.querySelector('#filter-search').value = '', document.querySelector('#filter-select').selectedIndex = 0, this.form.submit()"><i class="fa fa-refresh"></i></button>
@endif
```

---

When you "push" a directive, you need to call the "stack" in its parent layout.

https://laravel.com/docs/blade#building-layouts

---

`@if (!Auth::check()) ... @endif` or `@guest ... @endguest`

`@if (Auth::check())` or `@auth ... @endauth`

---

Variables are defined to its parent view.

```
<td colspan="{{ $numCol }}" class="text-center">
   @isset($message) {{ $message }} @else No record found. @endisset
</td>
```

## database

### factories

Insert a few records into your database.

https://laravel.com/docs/eloquent-factories

---

The naming convention for a factory begins with the model name followed by the suffix "Factory". This also applies to when making seeder file.

`php artisan make:factory DesignFactory`

---

The factory class is integrated with `fake()` method, so there's no need to call `$faker` from the "Faker\Factory" class. You can also access its property with `$this->faker`.

```php
public function definition(): array
{
   return [
      "name" => fake()->name(),
      "details" => fake()->text(),
      "location" => fake()->city(),
      /**
       * Uncommented this because we declared the fake data in
       * the DatabaseSeeder.
       */
      // "group_id" => Group::pluck("id")->random()
   ];
}
```

---

You can find more available faker formatters from here:

https://fakerphp.github.io/formatters/

---

Examples of defining factory:

```php
public function definition(): array
{
   return [
      "title" => $title = $this->faker->sentence(),
      "slug" => str()->slug($title),
      "image" => $this->faker->imageUrl($width = 1920, $height = 1280),
      "dimensions" => $width . "x" . $height,
      "views_count" => $this->faker->randomNumber(5),
      "downloads_count" => $this->faker->randomNumber(5),
      "is_published" => true,
      "user_id" => User::factory()
   ];
}
```

```php
public function definition(): array
{
   return [
      "name" => fake()->word(),
      "details" => fake()->text(),
      "location" => fake()->city()
   ];
}
```

```php
public function definition(): array
{
   return [
      "name" => fake()->sentence(),
      "description" => fake()->text()
   ];
}

public function completed () {
   return $this->state(function (array $attributes)  {
      return [
         "status" => true
      ];
   });
}

public function uncompleted () {
   return $this->state(function (array $attributes)  {
      return [
         "status" => false
      ];
   });
}

public function tomorrow () {
   return $this->state(function (array $attributes)  {
      return [
         "due_date" => now()->addDay()
      ];
   });
}

public function priority ($level = 1) {
   return $this->state(fn (array $attributes)  =>  [
      "priority" => $level
   ]);
}
```

### migrations

Starting from Laravel 11, the default database connection is SQLite for smoother development. Copy the full or absolute path of "database.sqlite" file in `DB_DATABASE` environment variable.

```
DB_CONNECTION=sqlite
DB_DATABASE=/home/laravel-project/database/database.sqlite
```

https://laravel.com/docs/database#sqlite-configuration

---

To implement the changes in the migration file, rerun the migration using the rollback or reset command after editing. However, do this only in the development environment, not on the production server, as it could result in data loss.

---

If the application is on the production server, create a migration file with a descriptive name (you can use camel case for naming, and it'll still output the file in snake case).

`php artisan make:migration createTablenameTable`

`php artisan make:migration addColumnnameToTablenameTable`

`php artisan make:migration remove_columnname_from_tablename_table`

`php artisan make:migration modify_columnname_in_tablename_table`

---

More of column modifiers in the Laravel  documentation. Follow the link under "migrations/" in the starters section of this file.

---

Migration example for creating table.

```php
public function up(): void
{
   Schema::create('groups', function (Blueprint $table) {
      $table->id();
      $table->string("name");
      $table->text("details")->nullable()->comment("about the group");
      $table->string("location")->nullable();
      $table->timestamps();
   });
}

public function down(): void
{
   Schema::dropIfExists('groups');
}
```

---

To successfully modify the database columns, we need to install the vendor package "doctrine/dbal" in our project.

`composer require doctrine/dbal`

```php
public function up(): void
{
   Schema::table('tasks', function (Blueprint $table) {
      $table->renameColumn("due_at", "due_date");
   });
}

public function down(): void
{
   Schema::table('tasks', function (Blueprint $table) {
      $table->renameColumn("due_date", "due_at");
   });
}
```

---

A foreign key constraint connects two tables using a key. Ensure that when linking table columns, they share the same data type to avoid an "incompatible referencing column and referenced column" error.

---

In development, when remigrating the table with foreign key, remember to manually delete the table column associated with the foreign key constraint to prevent a "duplicate column name" error, or you can just run a migration fresh or refresh command.

---

When dropping a column from a foreign table, you can use the `dropForeign()` method with a value: table name followed by the column name and then the word "foreign," with each terms separated by underscores (e.g., `dropForeign("tasks_user_id_foreign")`). Alternatively, you can reference the table column name within an array.

```php
public function down(): void
{
   Schema::table('tasks', function (Blueprint $table) {
      $table->dropForeign(["user_id"]);
      $table->dropColumn("user_id");
   });
}
```

---

The `constrained()` method serves as a shortcut for `->references('columnname')->on('tablename')`. You can specify in the `constrained()` method the table name that the foreign id should reference.

```php
public function up(): void
{
   Schema::table('tasks', function (Blueprint $table) {
      $table->foreignId("user_id")->after("id")->nullable()
         ->constrained()->cascadeOnUpdate()->cascadeOnDelete();
   });
}
```

---

Any additional column modifiers, such as `after()` and `nullable()`, must be called before the `constrained()`.

---

The "group_id" is a foreign key referencing the "id" column in the group table. In other words, a character's "group_id" corresponds to an "id" in the group table, establishing an eloquent relationship. This relationship is one-to-many, meaning a group can have many characters, and each character belongs to a single group.

```php
public function up(): void
{
   Schema::create('characters', function (Blueprint $table) {
      $table->id();
      $table->string("name");
      $table->text("details")->nullable();
      $table->string("location")->nullable();
      $table->foreignId("group_id")->nullable()
         ->constrained()->cascadeOnUpdate()->cascadeOnDelete();
      $table->timestamps();
   });
}
```

https://laravel.com/docs/eloquent-relationships

---

Add soft deletes migration command.

`php artisan make:migration add_deleted_at_to_groups`

```php
public function up(): void
{
   Schema::table('groups', function (Blueprint $table) {
      $table->softDeletes();
   });
}

public function down(): void
{
   Schema::table('groups', function (Blueprint $table) {
      $table->dropSoftDeletes();
   });
}
```

---

Other examples of defining migrations.

```php
public function up(): void
{
   Schema::table('users', function (Blueprint $table) {
      $table->string("profile_picture")->after("email")->nullable();
   });
}

public function down(): void
{
   Schema::table('users', function (Blueprint $table) {
      $table->dropColumn("profile_picture");
   });
}
```

```php
public function up(): void
{
   Schema::table('groups', function (Blueprint $table) {
      $table->foreignId("user_id")->after("location")->nullable()
         ->constrained()->cascadeOnUpdate()->cascadeOnDelete();
   });
}

public function down(): void
{
   Schema::table('groups', function (Blueprint $table) {
      $table->dropForeign(["user_id"]);
      $table->dropColumn("user_id");
   });
}
```

```php
public function up(): void
{
   Schema::create('designs', function (Blueprint $table) {
      $table->id();
      $table->string("title")->nullable();
      $table->string("slug")->nullable()->unique();
      $table->string("image");
      $table->string("dimensions");
      $table->unsignedInteger("views_count")->default(0);
      $table->unsignedInteger("downloads_count")->default(0);
      $table->boolean("is_published")->default(false);
      $table->foreignId("user_id")->constrained()->cascadeOnDelete();
      $table->timestamps();
   });
}

public function down(): void
{
   Schema::dropIfExists('designs');
}
```

### seeders

Seed your database with data defined by you.

https://laravel.com/docs/seeding

---

Define the data in separate seeder files following its database table columns.

```php
public function run(): void
{
   $groups = [];
   $faker = Faker::create();
   foreach (range(1, 3) as $index) {
      $group = [
            "name" => $faker->word(),
            "details" => $faker->text(),
            "location" => $faker->city(),
            "created_at" => now(),
            "updated_at" => now(),
      ];
      $groups[] = $group;
   }
   DB::table("groups")->insert($groups);
}
```

```php
public function run(): void
{
   $faker = Faker::create();
   $groups = Group::all();
   $characters = [];
   foreach ($groups as $group) {
      foreach (range(1, mt_rand(4, 6)) as $index) {
         $character = [
               "name" => $faker->name(),
               "details" => $faker->text(),
               "location" => $faker->city(),
               "group_id" => $group->id,
         ];
         $characters[] = $character;
      }
      Character::insert($characters);
   }
}
```

---

Make sure to enable the mass assignment in the model.

---

Run a specific seeder file.

`php artisan db:seed --class=GroupSeeder`

---

Call the seeder instances in DatabaseSeeder.php.

```php
$this->call([
   GroupSeeder::class,
   CharacterSeeder::class
]);
```

---

Call the factory instances in DatabaseSeeder.php. Group is called first because Character depends on Group.

```php
Group::factory(10)->create();
Character::factory(100)->create();
```

---

Call the factories with relationship models. The parent model Character and its child model Task. If the naming convention is not followed in the model, specify the relationship method defined in the model as the second argument of the `has()` method. The convention for naming relationship methods in the model is to use the plural form of the model's name. For example, the `tasks()` method in the Character model corresponds to the Task model.

```php
Character::factory()->has(
   Task::factory(5)->priority(3)->tomorrow(),
   "methodNameInModel"
)-create();
```

---

Call the factories with nested relationship models.

Scenario:

In the database, the "users" table has 10 users. The "groups" table has 50 groups. Each group has a link to the "users" table via the "user_id" column. The "characters" table has 500 characters. Each character has a "group_id" that links to the "groups" table's id. However, the "user_id" column is null.

Reason:

In this seeder file, the Group has a direct relationship with the User model, while the Character model has a direct relationship with the Group model. The Character model does not know where to link its "user_id" to, unlike the Group model, which automatically links the "user_id" to the User model's id. To sum up, the "group_id" in the "groups" table is not null, but the "user_id" in the "characters" table is null.

Fix:

Utilize the Factory `state()` method. The reason the Character's "user_id" is null is that it does not know where to link the "user_id" to. We have to manually define in the `state()` method that the Character's "user_id" links to the Group's "user_id" because the Group's "user_id" links to the User model's id.

```php
User::factory(5)->has(
   Group::factory(4)->has(
      Character::factory(3)->state(function ($attributes, Group $group) {
         return [
            "user_id" => $group->user_id
         ];
      })
   )
)->create();
```

---

You can simplify the call of factory with model relationships with this one-liner.

```php
Group::factory(10)->hasCharacters(10)->create();
```

---

The `for()` method establishes an inverse relationship to set values based on the parent model. For example, the following code creates five task model instances belonging to a single character.

```php
Task::factory(5)->for(
   Character::factory()
)->create();
```

---

The eloquent magic methods `has()` and `for()` have optional arguments to override table column values.

```php
Group::factory(10)->hasCharacters(10, [
   "status" => false
])->create();
```

```php
Group::factory(10)->forCharacter([
   "name" => "Jane"
])->create();
```

https://stackoverflow.com/questions/52918718/magic-methods-in-laravel

---

You can also override the values of table columns in the `create()` method.

```php
Design::factory()->count(3)->create([
   "slug" => "this-is-slug-style",
   "is_published" => false
]);
```

---

If you need to create a single record and persist it to the database in a single call, we use `create()`. On the other hand, the `insert()` method allows us to insert multiple records at once.  The `insert()` method is an instance from "Illuminate\Database\Query\Builder" while `create()` is from the "Illuminate\Database\Eloquent\Model".

```php
public function run(): void
{
   $faker = Faker::create();
   $groups = Group::all();
   $characters = [];

   foreach ($groups as $group) {
      foreach (range(1, mt_rand(4, 6)) as $index) {
            $character = [
               "name" => $faker->name(),
               "details" => $faker->text(),
               "location" => $faker->city(),
               "group_id" => $group->id,
            ];
            $characters[] = $character;
      }
      Character::insert($characters);
   }
}
```

---

After defining database factories and seeders, migrate afterwards.

---

To test a specific seeder file, run `php artisan db:seed --class=ExampleSeeder` or call it in DatabaseSeeder class and run `php artisan db:seed`

---

To avoid duplicates when seeding again or you can just run `php artisan migrate:fresh --seed`.